// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: appliance.sql

package db

import (
	"context"
)

const createAppliance = `-- name: CreateAppliance :exec

INSERT INTO appliances (
	name,
	zone
)
VALUES (
	?1,
	(SELECT id FROM zones z WHERE z.name = ?2)
)
`

type CreateApplianceParams struct {
	Name string
	Zone string
}

// CREATE
//
//	INSERT INTO appliances (
//		name,
//		zone
//	)
//	VALUES (
//		?1,
//		(SELECT id FROM zones z WHERE z.name = ?2)
//	)
func (q *Queries) CreateAppliance(ctx context.Context, arg CreateApplianceParams) error {
	_, err := q.db.ExecContext(ctx, createAppliance, arg.Name, arg.Zone)
	return err
}

const deleteAppliance = `-- name: DeleteAppliance :exec

DELETE FROM
	appliances
WHERE
	appliances.id = ?1
`

type DeleteApplianceParams struct {
	ID int64
}

// DELETE
//
//	DELETE FROM
//		appliances
//	WHERE
//		appliances.id = ?1
func (q *Queries) DeleteAppliance(ctx context.Context, arg DeleteApplianceParams) error {
	_, err := q.db.ExecContext(ctx, deleteAppliance, arg.ID)
	return err
}

const readAppliance = `-- name: ReadAppliance :one
SELECT
	a.id,
	a.name,
	z.name AS zone
FROM
	appliances a
JOIN
	zones z ON a.zone = z.id
WHERE
	a.name = ?1
	AND z.name = ?2
`

type ReadApplianceParams struct {
	Name string
	Zone string
}

type ReadApplianceRow struct {
	ID   int64
	Name string
	Zone string
}

// ReadAppliance
//
//	SELECT
//		a.id,
//		a.name,
//		z.name AS zone
//	FROM
//		appliances a
//	JOIN
//		zones z ON a.zone = z.id
//	WHERE
//		a.name = ?1
//		AND z.name = ?2
func (q *Queries) ReadAppliance(ctx context.Context, arg ReadApplianceParams) (ReadApplianceRow, error) {
	row := q.db.QueryRowContext(ctx, readAppliance, arg.Name, arg.Zone)
	var i ReadApplianceRow
	err := row.Scan(&i.ID, &i.Name, &i.Zone)
	return i, err
}

const readAppliances = `-- name: ReadAppliances :many

SELECT
	a.id,
	a.name,
	z.name AS zone
FROM
	appliances a
JOIN
	zones z ON a.zone = z.id
ORDER BY
	z.name,
	a.name
LIMIT
	COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
`

type ReadAppliancesParams struct {
	Offset interface{}
	Limit  interface{}
}

type ReadAppliancesRow struct {
	ID   int64
	Name string
	Zone string
}

// READ
//
//	SELECT
//		a.id,
//		a.name,
//		z.name AS zone
//	FROM
//		appliances a
//	JOIN
//		zones z ON a.zone = z.id
//	ORDER BY
//		z.name,
//		a.name
//	LIMIT
//		COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
func (q *Queries) ReadAppliances(ctx context.Context, arg ReadAppliancesParams) ([]ReadAppliancesRow, error) {
	rows, err := q.db.QueryContext(ctx, readAppliances, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadAppliancesRow
	for rows.Next() {
		var i ReadAppliancesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Zone); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readAppliancesByGlob = `-- name: ReadAppliancesByGlob :many
SELECT
	a.id,
	a.name,
	z.name AS zone
FROM
	appliances a
JOIN
	zones z ON a.zone = z.id
WHERE
	z.name = ?1
	AND a.name GLOB ?2
ORDER BY
	a.name
LIMIT
	COALESCE(NULLIF(?4, 0), 100) OFFSET COALESCE(?3, 0)
`

type ReadAppliancesByGlobParams struct {
	Zone   string
	Glob   string
	Offset interface{}
	Limit  interface{}
}

type ReadAppliancesByGlobRow struct {
	ID   int64
	Name string
	Zone string
}

// ReadAppliancesByGlob
//
//	SELECT
//		a.id,
//		a.name,
//		z.name AS zone
//	FROM
//		appliances a
//	JOIN
//		zones z ON a.zone = z.id
//	WHERE
//		z.name = ?1
//		AND a.name GLOB ?2
//	ORDER BY
//		a.name
//	LIMIT
//		COALESCE(NULLIF(?4, 0), 100) OFFSET COALESCE(?3, 0)
func (q *Queries) ReadAppliancesByGlob(ctx context.Context, arg ReadAppliancesByGlobParams) ([]ReadAppliancesByGlobRow, error) {
	rows, err := q.db.QueryContext(ctx, readAppliancesByGlob,
		arg.Zone,
		arg.Glob,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadAppliancesByGlobRow
	for rows.Next() {
		var i ReadAppliancesByGlobRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Zone); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readAppliancesByZone = `-- name: ReadAppliancesByZone :many
SELECT
	a.id,
	a.name,
	z.name AS zone
FROM
	appliances a
JOIN
	zones z ON a.zone = z.id
WHERE
	z.name = ?1
ORDER BY
	a.name
LIMIT
	COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
`

type ReadAppliancesByZoneParams struct {
	Zone   string
	Offset interface{}
	Limit  interface{}
}

type ReadAppliancesByZoneRow struct {
	ID   int64
	Name string
	Zone string
}

// ReadAppliancesByZone
//
//	SELECT
//		a.id,
//		a.name,
//		z.name AS zone
//	FROM
//		appliances a
//	JOIN
//		zones z ON a.zone = z.id
//	WHERE
//		z.name = ?1
//	ORDER BY
//		a.name
//	LIMIT
//		COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
func (q *Queries) ReadAppliancesByZone(ctx context.Context, arg ReadAppliancesByZoneParams) ([]ReadAppliancesByZoneRow, error) {
	rows, err := q.db.QueryContext(ctx, readAppliancesByZone, arg.Zone, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadAppliancesByZoneRow
	for rows.Next() {
		var i ReadAppliancesByZoneRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Zone); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApplianceName = `-- name: UpdateApplianceName :exec

UPDATE
	appliances
SET
	name = ?1
WHERE
	appliances.name = ?2
	AND zone = (SELECT id FROM zones z WHERE z.name = ?3)
`

type UpdateApplianceNameParams struct {
	Name      string
	Appliance string
	Zone      string
}

// UPDATE
//
//	UPDATE
//		appliances
//	SET
//		name = ?1
//	WHERE
//		appliances.name = ?2
//		AND zone = (SELECT id FROM zones z WHERE z.name = ?3)
func (q *Queries) UpdateApplianceName(ctx context.Context, arg UpdateApplianceNameParams) error {
	_, err := q.db.ExecContext(ctx, updateApplianceName, arg.Name, arg.Appliance, arg.Zone)
	return err
}
