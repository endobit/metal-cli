// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user_roles.sql

package db

import (
	"context"
)

const assignRoleToUser = `-- name: AssignRoleToUser :exec

INSERT INTO user_roles (
	user,
	role
)
VALUES (
	?1,
	?2
)
`

type AssignRoleToUserParams struct {
	UserID int64
	RoleID int64
}

// CREATE
//
//	INSERT INTO user_roles (
//		user,
//		role
//	)
//	VALUES (
//		?1,
//		?2
//	)
func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) error {
	_, err := q.db.ExecContext(ctx, assignRoleToUser, arg.UserID, arg.RoleID)
	return err
}

const deleteRoleFromUser = `-- name: DeleteRoleFromUser :exec


DELETE FROM
	user_roles
WHERE
	user = ?1
	AND role = ?2
`

type DeleteRoleFromUserParams struct {
	UserID int64
	RoleID int64
}

// UPDATE
//
// # DELETE
//
//	DELETE FROM
//		user_roles
//	WHERE
//		user = ?1
//		AND role = ?2
func (q *Queries) DeleteRoleFromUser(ctx context.Context, arg DeleteRoleFromUserParams) error {
	_, err := q.db.ExecContext(ctx, deleteRoleFromUser, arg.UserID, arg.RoleID)
	return err
}

const readRolesForUser = `-- name: ReadRolesForUser :many

SELECT
	r.id,
	r.name,
	r.description
FROM
	roles r
JOIN
	user_roles ur ON r.id = ur.role
WHERE
	ur.user = ?1
ORDER BY
	r.name
`

type ReadRolesForUserParams struct {
	UserID int64
}

// READ
//
//	SELECT
//		r.id,
//		r.name,
//		r.description
//	FROM
//		roles r
//	JOIN
//		user_roles ur ON r.id = ur.role
//	WHERE
//		ur.user = ?1
//	ORDER BY
//		r.name
func (q *Queries) ReadRolesForUser(ctx context.Context, arg ReadRolesForUserParams) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, readRolesForUser, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
