// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: model.sql

package db

import (
	"context"
)

const createModel = `-- name: CreateModel :exec

INSERT INTO models (
	make,
	name
)
VALUES (
	(SELECT id FROM makes m WHERE m.name = ?1),
	?2
)
`

type CreateModelParams struct {
	Make string
	Name string
}

// CREATE
//
//	INSERT INTO models (
//		make,
//		name
//	)
//	VALUES (
//		(SELECT id FROM makes m WHERE m.name = ?1),
//		?2
//	)
func (q *Queries) CreateModel(ctx context.Context, arg CreateModelParams) error {
	_, err := q.db.ExecContext(ctx, createModel, arg.Make, arg.Name)
	return err
}

const deleteModel = `-- name: DeleteModel :exec

DELETE FROM
	models
WHERE
	id = ?1
`

type DeleteModelParams struct {
	ID int64
}

// DELETE
//
//	DELETE FROM
//		models
//	WHERE
//		id = ?1
func (q *Queries) DeleteModel(ctx context.Context, arg DeleteModelParams) error {
	_, err := q.db.ExecContext(ctx, deleteModel, arg.ID)
	return err
}

const readModel = `-- name: ReadModel :one
SELECT
	m.id,
	mk.name AS make,
	m.name,
	m.architecture
FROM
	models m
JOIN
	makes mk ON m.make = mk.id
WHERE
	m.name = ?1
	AND mk.name = ?2
`

type ReadModelParams struct {
	Model string
	Make  string
}

type ReadModelRow struct {
	ID           int64
	Make         string
	Name         string
	Architecture *string
}

// ReadModel
//
//	SELECT
//		m.id,
//		mk.name AS make,
//		m.name,
//		m.architecture
//	FROM
//		models m
//	JOIN
//		makes mk ON m.make = mk.id
//	WHERE
//		m.name = ?1
//		AND mk.name = ?2
func (q *Queries) ReadModel(ctx context.Context, arg ReadModelParams) (ReadModelRow, error) {
	row := q.db.QueryRowContext(ctx, readModel, arg.Model, arg.Make)
	var i ReadModelRow
	err := row.Scan(
		&i.ID,
		&i.Make,
		&i.Name,
		&i.Architecture,
	)
	return i, err
}

const readModels = `-- name: ReadModels :many

SELECT
	m.id,
	mk.name AS make,
	m.name,
	m.architecture
FROM
	models m
JOIN
	makes mk ON m.make = mk.id
ORDER BY
	mk.name,
	m.name
LIMIT
	COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
`

type ReadModelsParams struct {
	Offset interface{}
	Limit  interface{}
}

type ReadModelsRow struct {
	ID           int64
	Make         string
	Name         string
	Architecture *string
}

// READ
//
//	SELECT
//		m.id,
//		mk.name AS make,
//		m.name,
//		m.architecture
//	FROM
//		models m
//	JOIN
//		makes mk ON m.make = mk.id
//	ORDER BY
//		mk.name,
//		m.name
//	LIMIT
//		COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
func (q *Queries) ReadModels(ctx context.Context, arg ReadModelsParams) ([]ReadModelsRow, error) {
	rows, err := q.db.QueryContext(ctx, readModels, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadModelsRow
	for rows.Next() {
		var i ReadModelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Make,
			&i.Name,
			&i.Architecture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readModelsByGlob = `-- name: ReadModelsByGlob :many
SELECT
	m.id,
	mk.name AS make,
	m.name,
	m.architecture
FROM
	models m
JOIN
	makes mk ON m.make = mk.id
WHERE
	m.name GLOB ?1
	AND mk.name = ?2
ORDER BY
	mk.name,
	m.name
LIMIT
	COALESCE(NULLIF(?4, 0), 100) OFFSET COALESCE(?3, 0)
`

type ReadModelsByGlobParams struct {
	Glob   string
	Make   string
	Offset interface{}
	Limit  interface{}
}

type ReadModelsByGlobRow struct {
	ID           int64
	Make         string
	Name         string
	Architecture *string
}

// ReadModelsByGlob
//
//	SELECT
//		m.id,
//		mk.name AS make,
//		m.name,
//		m.architecture
//	FROM
//		models m
//	JOIN
//		makes mk ON m.make = mk.id
//	WHERE
//		m.name GLOB ?1
//		AND mk.name = ?2
//	ORDER BY
//		mk.name,
//		m.name
//	LIMIT
//		COALESCE(NULLIF(?4, 0), 100) OFFSET COALESCE(?3, 0)
func (q *Queries) ReadModelsByGlob(ctx context.Context, arg ReadModelsByGlobParams) ([]ReadModelsByGlobRow, error) {
	rows, err := q.db.QueryContext(ctx, readModelsByGlob,
		arg.Glob,
		arg.Make,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadModelsByGlobRow
	for rows.Next() {
		var i ReadModelsByGlobRow
		if err := rows.Scan(
			&i.ID,
			&i.Make,
			&i.Name,
			&i.Architecture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readModelsByMake = `-- name: ReadModelsByMake :many
SELECT
	m.id,
	mk.name AS make,
	m.name,
	m.architecture
FROM
	models m
JOIN
	makes mk ON m.make = mk.id
WHERE
	mk.name = ?1
ORDER BY
	mk.name,
	m.name
LIMIT
	COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
`

type ReadModelsByMakeParams struct {
	Make   string
	Offset interface{}
	Limit  interface{}
}

type ReadModelsByMakeRow struct {
	ID           int64
	Make         string
	Name         string
	Architecture *string
}

// ReadModelsByMake
//
//	SELECT
//		m.id,
//		mk.name AS make,
//		m.name,
//		m.architecture
//	FROM
//		models m
//	JOIN
//		makes mk ON m.make = mk.id
//	WHERE
//		mk.name = ?1
//	ORDER BY
//		mk.name,
//		m.name
//	LIMIT
//		COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
func (q *Queries) ReadModelsByMake(ctx context.Context, arg ReadModelsByMakeParams) ([]ReadModelsByMakeRow, error) {
	rows, err := q.db.QueryContext(ctx, readModelsByMake, arg.Make, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadModelsByMakeRow
	for rows.Next() {
		var i ReadModelsByMakeRow
		if err := rows.Scan(
			&i.ID,
			&i.Make,
			&i.Name,
			&i.Architecture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateModelArchitecture = `-- name: UpdateModelArchitecture :exec
UPDATE
	models
SET
	architecture = ?1
WHERE
	models.name = ?2
	AND make = (SELECT id FROM makes m WHERE m.name = ?3)
`

type UpdateModelArchitectureParams struct {
	Architecture *string
	Model        string
	Make         string
}

// UpdateModelArchitecture
//
//	UPDATE
//		models
//	SET
//		architecture = ?1
//	WHERE
//		models.name = ?2
//		AND make = (SELECT id FROM makes m WHERE m.name = ?3)
func (q *Queries) UpdateModelArchitecture(ctx context.Context, arg UpdateModelArchitectureParams) error {
	_, err := q.db.ExecContext(ctx, updateModelArchitecture, arg.Architecture, arg.Model, arg.Make)
	return err
}

const updateModelName = `-- name: UpdateModelName :exec

UPDATE
	models
SET
	name = ?1
WHERE
	models.name = ?2
	AND make = (SELECT id FROM makes m WHERE m.name = ?3)
`

type UpdateModelNameParams struct {
	Name  string
	Model string
	Make  string
}

// UPDATE
//
//	UPDATE
//		models
//	SET
//		name = ?1
//	WHERE
//		models.name = ?2
//		AND make = (SELECT id FROM makes m WHERE m.name = ?3)
func (q *Queries) UpdateModelName(ctx context.Context, arg UpdateModelNameParams) error {
	_, err := q.db.ExecContext(ctx, updateModelName, arg.Name, arg.Model, arg.Make)
	return err
}
