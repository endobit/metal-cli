// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: rack.sql

package db

import (
	"context"
)

const createRack = `-- name: CreateRack :exec

INSERT INTO racks (
	zone,
	name
)
VALUES (
	(SELECT id FROM zones z WHERE z.name = ?1),
	?2
)
`

type CreateRackParams struct {
	Zone string
	Name string
}

// CREATE
//
//	INSERT INTO racks (
//		zone,
//		name
//	)
//	VALUES (
//		(SELECT id FROM zones z WHERE z.name = ?1),
//		?2
//	)
func (q *Queries) CreateRack(ctx context.Context, arg CreateRackParams) error {
	_, err := q.db.ExecContext(ctx, createRack, arg.Zone, arg.Name)
	return err
}

const deleteRack = `-- name: DeleteRack :exec

DELETE FROM
	racks
WHERE
	racks.id = ?1
`

type DeleteRackParams struct {
	ID int64
}

// DELETE
//
//	DELETE FROM
//		racks
//	WHERE
//		racks.id = ?1
func (q *Queries) DeleteRack(ctx context.Context, arg DeleteRackParams) error {
	_, err := q.db.ExecContext(ctx, deleteRack, arg.ID)
	return err
}

const readRack = `-- name: ReadRack :one
SELECT
	r.id,
	r.name,
	z.name AS zone
FROM
	racks r
JOIN
	zones z ON r.zone = z.id
WHERE
	r.name = ?1
	AND z.name = ?2
`

type ReadRackParams struct {
	Name string
	Zone string
}

type ReadRackRow struct {
	ID   int64
	Name string
	Zone string
}

// ReadRack
//
//	SELECT
//		r.id,
//		r.name,
//		z.name AS zone
//	FROM
//		racks r
//	JOIN
//		zones z ON r.zone = z.id
//	WHERE
//		r.name = ?1
//		AND z.name = ?2
func (q *Queries) ReadRack(ctx context.Context, arg ReadRackParams) (ReadRackRow, error) {
	row := q.db.QueryRowContext(ctx, readRack, arg.Name, arg.Zone)
	var i ReadRackRow
	err := row.Scan(&i.ID, &i.Name, &i.Zone)
	return i, err
}

const readRacks = `-- name: ReadRacks :many

SELECT
	r.id,
	r.name,
	z.name AS zone
FROM
	racks r
JOIN
	zones z ON r.zone = z.id
ORDER BY
	z.name,
	r.name
LIMIT
	COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
`

type ReadRacksParams struct {
	Offset interface{}
	Limit  interface{}
}

type ReadRacksRow struct {
	ID   int64
	Name string
	Zone string
}

// READ
//
//	SELECT
//		r.id,
//		r.name,
//		z.name AS zone
//	FROM
//		racks r
//	JOIN
//		zones z ON r.zone = z.id
//	ORDER BY
//		z.name,
//		r.name
//	LIMIT
//		COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
func (q *Queries) ReadRacks(ctx context.Context, arg ReadRacksParams) ([]ReadRacksRow, error) {
	rows, err := q.db.QueryContext(ctx, readRacks, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadRacksRow
	for rows.Next() {
		var i ReadRacksRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Zone); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readRacksByGlob = `-- name: ReadRacksByGlob :many
SELECT
	r.id,
	r.name,
	z.name AS zone
FROM
	racks r
JOIN
	zones z ON r.zone = z.id
WHERE
	z.name = ?1
	AND r.name GLOB ?2
ORDER BY
	r.name
LIMIT
	COALESCE(NULLIF(?4, 0), 100) OFFSET COALESCE(?3, 0)
`

type ReadRacksByGlobParams struct {
	Zone   string
	Glob   string
	Offset interface{}
	Limit  interface{}
}

type ReadRacksByGlobRow struct {
	ID   int64
	Name string
	Zone string
}

// ReadRacksByGlob
//
//	SELECT
//		r.id,
//		r.name,
//		z.name AS zone
//	FROM
//		racks r
//	JOIN
//		zones z ON r.zone = z.id
//	WHERE
//		z.name = ?1
//		AND r.name GLOB ?2
//	ORDER BY
//		r.name
//	LIMIT
//		COALESCE(NULLIF(?4, 0), 100) OFFSET COALESCE(?3, 0)
func (q *Queries) ReadRacksByGlob(ctx context.Context, arg ReadRacksByGlobParams) ([]ReadRacksByGlobRow, error) {
	rows, err := q.db.QueryContext(ctx, readRacksByGlob,
		arg.Zone,
		arg.Glob,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadRacksByGlobRow
	for rows.Next() {
		var i ReadRacksByGlobRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Zone); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readRacksByZone = `-- name: ReadRacksByZone :many
SELECT
	r.id,
	r.name,
	z.name AS zone
FROM
	racks r
JOIN
	zones z ON r.zone = z.id
WHERE
	z.name = ?1
ORDER BY
	r.name
LIMIT
	COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
`

type ReadRacksByZoneParams struct {
	Zone   string
	Offset interface{}
	Limit  interface{}
}

type ReadRacksByZoneRow struct {
	ID   int64
	Name string
	Zone string
}

// ReadRacksByZone
//
//	SELECT
//		r.id,
//		r.name,
//		z.name AS zone
//	FROM
//		racks r
//	JOIN
//		zones z ON r.zone = z.id
//	WHERE
//		z.name = ?1
//	ORDER BY
//		r.name
//	LIMIT
//		COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
func (q *Queries) ReadRacksByZone(ctx context.Context, arg ReadRacksByZoneParams) ([]ReadRacksByZoneRow, error) {
	rows, err := q.db.QueryContext(ctx, readRacksByZone, arg.Zone, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadRacksByZoneRow
	for rows.Next() {
		var i ReadRacksByZoneRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Zone); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRackName = `-- name: UpdateRackName :exec

UPDATE
	racks
SET
	name = ?1
WHERE
	racks.name = ?2
	AND zone = (SELECT id FROM zones z WHERE z.name = ?3)
`

type UpdateRackNameParams struct {
	Name string
	Rack string
	Zone string
}

// UPDATE
//
//	UPDATE
//		racks
//	SET
//		name = ?1
//	WHERE
//		racks.name = ?2
//		AND zone = (SELECT id FROM zones z WHERE z.name = ?3)
func (q *Queries) UpdateRackName(ctx context.Context, arg UpdateRackNameParams) error {
	_, err := q.db.ExecContext(ctx, updateRackName, arg.Name, arg.Rack, arg.Zone)
	return err
}
