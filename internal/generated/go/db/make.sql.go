// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: make.sql

package db

import (
	"context"
)

const createMake = `-- name: CreateMake :exec

INSERT INTO makes (
	name
)
VALUES (
	?1
)
`

type CreateMakeParams struct {
	Name string
}

// CREATE
//
//	INSERT INTO makes (
//		name
//	)
//	VALUES (
//		?1
//	)
func (q *Queries) CreateMake(ctx context.Context, arg CreateMakeParams) error {
	_, err := q.db.ExecContext(ctx, createMake, arg.Name)
	return err
}

const deleteMake = `-- name: DeleteMake :exec

DELETE FROM
	makes
WHERE
	id = ?1
`

type DeleteMakeParams struct {
	ID int64
}

// DELETE
//
//	DELETE FROM
//		makes
//	WHERE
//		id = ?1
func (q *Queries) DeleteMake(ctx context.Context, arg DeleteMakeParams) error {
	_, err := q.db.ExecContext(ctx, deleteMake, arg.ID)
	return err
}

const readMake = `-- name: ReadMake :one
SELECT
	id,
	name
FROM
	makes
WHERE
	name = ?1
`

type ReadMakeParams struct {
	Make string
}

// ReadMake
//
//	SELECT
//		id,
//		name
//	FROM
//		makes
//	WHERE
//		name = ?1
func (q *Queries) ReadMake(ctx context.Context, arg ReadMakeParams) (Make, error) {
	row := q.db.QueryRowContext(ctx, readMake, arg.Make)
	var i Make
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const readMakes = `-- name: ReadMakes :many

SELECT
	id,
	name
FROM
	makes
ORDER BY
	name
LIMIT
	COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
`

type ReadMakesParams struct {
	Offset interface{}
	Limit  interface{}
}

// READ
//
//	SELECT
//		id,
//		name
//	FROM
//		makes
//	ORDER BY
//		name
//	LIMIT
//		COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
func (q *Queries) ReadMakes(ctx context.Context, arg ReadMakesParams) ([]Make, error) {
	rows, err := q.db.QueryContext(ctx, readMakes, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Make
	for rows.Next() {
		var i Make
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readMakesByGlob = `-- name: ReadMakesByGlob :many
SELECT
	id,
	name
FROM
	makes
WHERE
	name GLOB ?1
ORDER BY
	name
LIMIT
	COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
`

type ReadMakesByGlobParams struct {
	Glob   string
	Offset interface{}
	Limit  interface{}
}

// ReadMakesByGlob
//
//	SELECT
//		id,
//		name
//	FROM
//		makes
//	WHERE
//		name GLOB ?1
//	ORDER BY
//		name
//	LIMIT
//		COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
func (q *Queries) ReadMakesByGlob(ctx context.Context, arg ReadMakesByGlobParams) ([]Make, error) {
	rows, err := q.db.QueryContext(ctx, readMakesByGlob, arg.Glob, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Make
	for rows.Next() {
		var i Make
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMakeName = `-- name: UpdateMakeName :exec

UPDATE
	makes
SET
	name = ?1
WHERE
	name = ?2
`

type UpdateMakeNameParams struct {
	Name string
	Make string
}

// UPDATE
//
//	UPDATE
//		makes
//	SET
//		name = ?1
//	WHERE
//		name = ?2
func (q *Queries) UpdateMakeName(ctx context.Context, arg UpdateMakeNameParams) error {
	_, err := q.db.ExecContext(ctx, updateMakeName, arg.Name, arg.Make)
	return err
}
