// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: host.sql

package db

import (
	"context"
)

const createHost = `-- name: CreateHost :exec

INSERT INTO hosts (
	zone,
	cluster,
	name
)
VALUES (
	(SELECT id FROM zones z WHERE z.name = ?1),
	(SELECT id FROM clusters c WHERE c.name = ?2 AND zone = (SELECT id FROM zones z WHERE z.name = ?1)),
	?3
)
`

type CreateHostParams struct {
	Zone    string
	Cluster string
	Name    string
}

// CREATE
//
//	INSERT INTO hosts (
//		zone,
//		cluster,
//		name
//	)
//	VALUES (
//		(SELECT id FROM zones z WHERE z.name = ?1),
//		(SELECT id FROM clusters c WHERE c.name = ?2 AND zone = (SELECT id FROM zones z WHERE z.name = ?1)),
//		?3
//	)
func (q *Queries) CreateHost(ctx context.Context, arg CreateHostParams) error {
	_, err := q.db.ExecContext(ctx, createHost, arg.Zone, arg.Cluster, arg.Name)
	return err
}

const deleteHost = `-- name: DeleteHost :exec

DELETE FROM
	hosts
WHERE
	id = ?1
`

type DeleteHostParams struct {
	ID int64
}

// DELETE
//
//	DELETE FROM
//		hosts
//	WHERE
//		id = ?1
func (q *Queries) DeleteHost(ctx context.Context, arg DeleteHostParams) error {
	_, err := q.db.ExecContext(ctx, deleteHost, arg.ID)
	return err
}

const readHost = `-- name: ReadHost :one
SELECT
	h.id,
	h.name,
	mk.name AS make,
	m.name AS model,
	e.name AS environment,
	a.name AS appliance,
	h.location,
	r.name AS rack,
	h.rank,
	h.slot,
	z.name AS zone,
	c.name AS cluster
FROM
	hosts h
LEFT JOIN
	zones z ON COALESCE(h.zone, c.zone) = z.id
LEFT JOIN
	clusters c ON h.cluster = c.id
LEFT JOIN
	models m ON h.model = m.id
LEFT JOIN
	makes mk ON m.make = mk.id
LEFT JOIN
	environments e ON h.environment = e.id
LEFT JOIN
	appliances a ON h.appliance = a.id
LEFT JOIN
	racks r ON h.rack = r.id
WHERE
	h.name = ?1
	AND (
		(h.zone IS NOT NULL AND z.name = ?2) -- Standalone host
		OR (h.cluster IS NOT NULL AND c.name = ?3 AND z.name = ?2) -- Clustered host
	)
`

type ReadHostParams struct {
	Name    string
	Zone    string
	Cluster string
}

type ReadHostRow struct {
	ID          int64
	Name        string
	Make        *string
	Model       *string
	Environment *string
	Appliance   *string
	Location    *string
	Rack        *string
	Rank        *int64
	Slot        *int64
	Zone        *string
	Cluster     *string
}

// ReadHost
//
//	SELECT
//		h.id,
//		h.name,
//		mk.name AS make,
//		m.name AS model,
//		e.name AS environment,
//		a.name AS appliance,
//		h.location,
//		r.name AS rack,
//		h.rank,
//		h.slot,
//		z.name AS zone,
//		c.name AS cluster
//	FROM
//		hosts h
//	LEFT JOIN
//		zones z ON COALESCE(h.zone, c.zone) = z.id
//	LEFT JOIN
//		clusters c ON h.cluster = c.id
//	LEFT JOIN
//		models m ON h.model = m.id
//	LEFT JOIN
//		makes mk ON m.make = mk.id
//	LEFT JOIN
//		environments e ON h.environment = e.id
//	LEFT JOIN
//		appliances a ON h.appliance = a.id
//	LEFT JOIN
//		racks r ON h.rack = r.id
//	WHERE
//		h.name = ?1
//		AND (
//			(h.zone IS NOT NULL AND z.name = ?2) -- Standalone host
//			OR (h.cluster IS NOT NULL AND c.name = ?3 AND z.name = ?2) -- Clustered host
//		)
func (q *Queries) ReadHost(ctx context.Context, arg ReadHostParams) (ReadHostRow, error) {
	row := q.db.QueryRowContext(ctx, readHost, arg.Name, arg.Zone, arg.Cluster)
	var i ReadHostRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Make,
		&i.Model,
		&i.Environment,
		&i.Appliance,
		&i.Location,
		&i.Rack,
		&i.Rank,
		&i.Slot,
		&i.Zone,
		&i.Cluster,
	)
	return i, err
}

const readHosts = `-- name: ReadHosts :many

SELECT
	h.id,
	h.name,
	mk.name AS make,
	m.name AS model,
	e.name AS environment,
	a.name AS appliance,
	h.location,
	r.name AS rack,
	h.rank,
	h.slot,
	z.name AS zone,
	c.name AS cluster
FROM
	hosts h
LEFT JOIN
	zones z ON COALESCE(h.zone, c.zone) = z.id
LEFT JOIN
	clusters c ON h.cluster = c.id
LEFT JOIN
	models m ON h.model = m.id
LEFT JOIN
	makes mk ON m.make = mk.id
LEFT JOIN
	environments e ON h.environment = e.id
LEFT JOIN
	appliances a ON h.appliance = a.id
LEFT JOIN
	racks r ON h.rack = r.id
ORDER BY
	z.name,
	COALESCE(c.name, ''),
	h.name
LIMIT
	COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
`

type ReadHostsParams struct {
	Offset interface{}
	Limit  interface{}
}

type ReadHostsRow struct {
	ID          int64
	Name        string
	Make        *string
	Model       *string
	Environment *string
	Appliance   *string
	Location    *string
	Rack        *string
	Rank        *int64
	Slot        *int64
	Zone        *string
	Cluster     *string
}

// READ
//
//	SELECT
//		h.id,
//		h.name,
//		mk.name AS make,
//		m.name AS model,
//		e.name AS environment,
//		a.name AS appliance,
//		h.location,
//		r.name AS rack,
//		h.rank,
//		h.slot,
//		z.name AS zone,
//		c.name AS cluster
//	FROM
//		hosts h
//	LEFT JOIN
//		zones z ON COALESCE(h.zone, c.zone) = z.id
//	LEFT JOIN
//		clusters c ON h.cluster = c.id
//	LEFT JOIN
//		models m ON h.model = m.id
//	LEFT JOIN
//		makes mk ON m.make = mk.id
//	LEFT JOIN
//		environments e ON h.environment = e.id
//	LEFT JOIN
//		appliances a ON h.appliance = a.id
//	LEFT JOIN
//		racks r ON h.rack = r.id
//	ORDER BY
//		z.name,
//		COALESCE(c.name, ''),
//		h.name
//	LIMIT
//		COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
func (q *Queries) ReadHosts(ctx context.Context, arg ReadHostsParams) ([]ReadHostsRow, error) {
	rows, err := q.db.QueryContext(ctx, readHosts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadHostsRow
	for rows.Next() {
		var i ReadHostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Make,
			&i.Model,
			&i.Environment,
			&i.Appliance,
			&i.Location,
			&i.Rack,
			&i.Rank,
			&i.Slot,
			&i.Zone,
			&i.Cluster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readHostsByCluster = `-- name: ReadHostsByCluster :many
SELECT
	h.id,
	h.name,
	mk.name AS make,
	m.name AS model,
	e.name AS environment,
	a.name AS appliance,
	h.location,
	r.name AS rack,
	h.rank,
	h.slot,
	z.name AS zone,
	c.name AS cluster
FROM
	hosts h
LEFT JOIN
	zones z ON c.zone = z.id
LEFT JOIN
	clusters c ON h.cluster = c.id
LEFT JOIN
	models m ON h.model = m.id
LEFT JOIN
	makes mk ON m.make = mk.id
LEFT JOIN
	environments e ON h.environment = e.id
LEFT JOIN
	appliances a ON h.appliance = a.id
LEFT JOIN
	racks r ON h.rack = r.id
WHERE
	c.name = ?1
	AND z.name = ?2

ORDER BY
	z.name,
	c.name,
	h.name
LIMIT
	COALESCE(NULLIF(?4, 0), 100) OFFSET COALESCE(?3, 0)
`

type ReadHostsByClusterParams struct {
	Cluster string
	Zone    string
	Offset  interface{}
	Limit   interface{}
}

type ReadHostsByClusterRow struct {
	ID          int64
	Name        string
	Make        *string
	Model       *string
	Environment *string
	Appliance   *string
	Location    *string
	Rack        *string
	Rank        *int64
	Slot        *int64
	Zone        *string
	Cluster     *string
}

// ReadHostsByCluster
//
//	SELECT
//		h.id,
//		h.name,
//		mk.name AS make,
//		m.name AS model,
//		e.name AS environment,
//		a.name AS appliance,
//		h.location,
//		r.name AS rack,
//		h.rank,
//		h.slot,
//		z.name AS zone,
//		c.name AS cluster
//	FROM
//		hosts h
//	LEFT JOIN
//		zones z ON c.zone = z.id
//	LEFT JOIN
//		clusters c ON h.cluster = c.id
//	LEFT JOIN
//		models m ON h.model = m.id
//	LEFT JOIN
//		makes mk ON m.make = mk.id
//	LEFT JOIN
//		environments e ON h.environment = e.id
//	LEFT JOIN
//		appliances a ON h.appliance = a.id
//	LEFT JOIN
//		racks r ON h.rack = r.id
//	WHERE
//		c.name = ?1
//		AND z.name = ?2
//
//	ORDER BY
//		z.name,
//		c.name,
//		h.name
//	LIMIT
//		COALESCE(NULLIF(?4, 0), 100) OFFSET COALESCE(?3, 0)
func (q *Queries) ReadHostsByCluster(ctx context.Context, arg ReadHostsByClusterParams) ([]ReadHostsByClusterRow, error) {
	rows, err := q.db.QueryContext(ctx, readHostsByCluster,
		arg.Cluster,
		arg.Zone,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadHostsByClusterRow
	for rows.Next() {
		var i ReadHostsByClusterRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Make,
			&i.Model,
			&i.Environment,
			&i.Appliance,
			&i.Location,
			&i.Rack,
			&i.Rank,
			&i.Slot,
			&i.Zone,
			&i.Cluster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readHostsByGlob = `-- name: ReadHostsByGlob :many
SELECT
	h.id,
	h.name,
	mk.name AS make,
	m.name AS model,
	e.name AS environment,
	a.name AS appliance,
	h.location,
	r.name AS rack,
	h.rank,
	h.slot,
	z.name AS zone,
	c.name AS cluster
FROM
	hosts h
LEFT JOIN
	zones z ON COALESCE(h.zone, c.zone) = z.id
LEFT JOIN
	clusters c ON h.cluster = c.id
LEFT JOIN
	models m ON h.model = m.id
LEFT JOIN
	makes mk ON m.make = mk.id
LEFT JOIN
	environments e ON h.environment = e.id
LEFT JOIN
	appliances a ON h.appliance = a.id
LEFT JOIN
	racks r ON h.rack = r.id
WHERE
	h.name GLOB ?1
	AND (
		(h.zone IS NOT NULL AND z.name = ?2) -- Standalone host
		OR (h.cluster IS NOT NULL AND c.name = ?3 AND z.name = ?2) -- Clustered host
	)
ORDER BY
	z.name,
	COALESCE(c.name, ''),
	h.name
LIMIT
	COALESCE(NULLIF(?5, 0), 100) OFFSET COALESCE(?4, 0)
`

type ReadHostsByGlobParams struct {
	Glob    string
	Zone    string
	Cluster string
	Offset  interface{}
	Limit   interface{}
}

type ReadHostsByGlobRow struct {
	ID          int64
	Name        string
	Make        *string
	Model       *string
	Environment *string
	Appliance   *string
	Location    *string
	Rack        *string
	Rank        *int64
	Slot        *int64
	Zone        *string
	Cluster     *string
}

// ReadHostsByGlob
//
//	SELECT
//		h.id,
//		h.name,
//		mk.name AS make,
//		m.name AS model,
//		e.name AS environment,
//		a.name AS appliance,
//		h.location,
//		r.name AS rack,
//		h.rank,
//		h.slot,
//		z.name AS zone,
//		c.name AS cluster
//	FROM
//		hosts h
//	LEFT JOIN
//		zones z ON COALESCE(h.zone, c.zone) = z.id
//	LEFT JOIN
//		clusters c ON h.cluster = c.id
//	LEFT JOIN
//		models m ON h.model = m.id
//	LEFT JOIN
//		makes mk ON m.make = mk.id
//	LEFT JOIN
//		environments e ON h.environment = e.id
//	LEFT JOIN
//		appliances a ON h.appliance = a.id
//	LEFT JOIN
//		racks r ON h.rack = r.id
//	WHERE
//		h.name GLOB ?1
//		AND (
//			(h.zone IS NOT NULL AND z.name = ?2) -- Standalone host
//			OR (h.cluster IS NOT NULL AND c.name = ?3 AND z.name = ?2) -- Clustered host
//		)
//	ORDER BY
//		z.name,
//		COALESCE(c.name, ''),
//		h.name
//	LIMIT
//		COALESCE(NULLIF(?5, 0), 100) OFFSET COALESCE(?4, 0)
func (q *Queries) ReadHostsByGlob(ctx context.Context, arg ReadHostsByGlobParams) ([]ReadHostsByGlobRow, error) {
	rows, err := q.db.QueryContext(ctx, readHostsByGlob,
		arg.Glob,
		arg.Zone,
		arg.Cluster,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadHostsByGlobRow
	for rows.Next() {
		var i ReadHostsByGlobRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Make,
			&i.Model,
			&i.Environment,
			&i.Appliance,
			&i.Location,
			&i.Rack,
			&i.Rank,
			&i.Slot,
			&i.Zone,
			&i.Cluster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readHostsByZone = `-- name: ReadHostsByZone :many
SELECT
	h.id,
	h.name,
	mk.name AS make,
	m.name AS model,
	e.name AS environment,
	a.name AS appliance,
	h.location,
	r.name AS rack,
	h.rank,
	h.slot,
	z.name AS zone,
	c.name AS cluster
FROM
	hosts h
LEFT JOIN
	zones z ON COALESCE(h.zone, c.zone) = z.id
LEFT JOIN
	clusters c ON h.cluster = c.id
LEFT JOIN
	models m ON h.model = m.id
LEFT JOIN
	makes mk ON m.make = mk.id
LEFT JOIN
	environments e ON h.environment = e.id
LEFT JOIN
	appliances a ON h.appliance = a.id
LEFT JOIN
	racks r ON h.rack = r.id
WHERE
	z.name = ?1
ORDER BY
	COALESCE(c.name, ''),
	h.name
LIMIT
	COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
`

type ReadHostsByZoneParams struct {
	Zone   string
	Offset interface{}
	Limit  interface{}
}

type ReadHostsByZoneRow struct {
	ID          int64
	Name        string
	Make        *string
	Model       *string
	Environment *string
	Appliance   *string
	Location    *string
	Rack        *string
	Rank        *int64
	Slot        *int64
	Zone        *string
	Cluster     *string
}

// ReadHostsByZone
//
//	SELECT
//		h.id,
//		h.name,
//		mk.name AS make,
//		m.name AS model,
//		e.name AS environment,
//		a.name AS appliance,
//		h.location,
//		r.name AS rack,
//		h.rank,
//		h.slot,
//		z.name AS zone,
//		c.name AS cluster
//	FROM
//		hosts h
//	LEFT JOIN
//		zones z ON COALESCE(h.zone, c.zone) = z.id
//	LEFT JOIN
//		clusters c ON h.cluster = c.id
//	LEFT JOIN
//		models m ON h.model = m.id
//	LEFT JOIN
//		makes mk ON m.make = mk.id
//	LEFT JOIN
//		environments e ON h.environment = e.id
//	LEFT JOIN
//		appliances a ON h.appliance = a.id
//	LEFT JOIN
//		racks r ON h.rack = r.id
//	WHERE
//		z.name = ?1
//	ORDER BY
//		COALESCE(c.name, ''),
//		h.name
//	LIMIT
//		COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
func (q *Queries) ReadHostsByZone(ctx context.Context, arg ReadHostsByZoneParams) ([]ReadHostsByZoneRow, error) {
	rows, err := q.db.QueryContext(ctx, readHostsByZone, arg.Zone, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadHostsByZoneRow
	for rows.Next() {
		var i ReadHostsByZoneRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Make,
			&i.Model,
			&i.Environment,
			&i.Appliance,
			&i.Location,
			&i.Rack,
			&i.Rank,
			&i.Slot,
			&i.Zone,
			&i.Cluster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHostAppliance = `-- name: UpdateHostAppliance :exec
UPDATE
	hosts
SET
	appliance = (SELECT id FROM appliances a WHERE a.name = ?1)
WHERE
	hosts.name = ?2
	AND (
		(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
		OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
	)
`

type UpdateHostApplianceParams struct {
	Appliance string
	Host      string
	Zone      string
	Cluster   string
}

// UpdateHostAppliance
//
//	UPDATE
//		hosts
//	SET
//		appliance = (SELECT id FROM appliances a WHERE a.name = ?1)
//	WHERE
//		hosts.name = ?2
//		AND (
//			(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
//			OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
//		)
func (q *Queries) UpdateHostAppliance(ctx context.Context, arg UpdateHostApplianceParams) error {
	_, err := q.db.ExecContext(ctx, updateHostAppliance,
		arg.Appliance,
		arg.Host,
		arg.Zone,
		arg.Cluster,
	)
	return err
}

const updateHostEnvironment = `-- name: UpdateHostEnvironment :exec
UPDATE
	hosts
SET
	environment = (SELECT id FROM environments e WHERE e.name = ?1)
WHERE
	hosts.name = ?2
	AND (
		(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
		OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
	)
`

type UpdateHostEnvironmentParams struct {
	Environment string
	Host        string
	Zone        string
	Cluster     string
}

// UpdateHostEnvironment
//
//	UPDATE
//		hosts
//	SET
//		environment = (SELECT id FROM environments e WHERE e.name = ?1)
//	WHERE
//		hosts.name = ?2
//		AND (
//			(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
//			OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
//		)
func (q *Queries) UpdateHostEnvironment(ctx context.Context, arg UpdateHostEnvironmentParams) error {
	_, err := q.db.ExecContext(ctx, updateHostEnvironment,
		arg.Environment,
		arg.Host,
		arg.Zone,
		arg.Cluster,
	)
	return err
}

const updateHostLocation = `-- name: UpdateHostLocation :exec
UPDATE
	hosts
SET
	location = ?1
WHERE
	hosts.name = ?2
	AND (
		(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
		OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
	)
`

type UpdateHostLocationParams struct {
	Location *string
	Host     string
	Zone     string
	Cluster  string
}

// UpdateHostLocation
//
//	UPDATE
//		hosts
//	SET
//		location = ?1
//	WHERE
//		hosts.name = ?2
//		AND (
//			(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
//			OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
//		)
func (q *Queries) UpdateHostLocation(ctx context.Context, arg UpdateHostLocationParams) error {
	_, err := q.db.ExecContext(ctx, updateHostLocation,
		arg.Location,
		arg.Host,
		arg.Zone,
		arg.Cluster,
	)
	return err
}

const updateHostModel = `-- name: UpdateHostModel :exec
UPDATE
	hosts
SET
	model = (
		SELECT m.id
		FROM models m
		JOIN makes mk ON m.make = mk.id
		WHERE m.name = ?1 AND mk.name = ?2
	)
WHERE
	hosts.name = ?3
	AND (
		(zone = (SELECT id FROM zones z WHERE z.name = ?4) AND cluster IS NULL)
		OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?5 AND zone = (SELECT id FROM zones z WHERE z.name = ?4)))
	)
`

type UpdateHostModelParams struct {
	Model   string
	Make    string
	Host    string
	Zone    string
	Cluster string
}

// UpdateHostModel
//
//	UPDATE
//		hosts
//	SET
//		model = (
//			SELECT m.id
//			FROM models m
//			JOIN makes mk ON m.make = mk.id
//			WHERE m.name = ?1 AND mk.name = ?2
//		)
//	WHERE
//		hosts.name = ?3
//		AND (
//			(zone = (SELECT id FROM zones z WHERE z.name = ?4) AND cluster IS NULL)
//			OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?5 AND zone = (SELECT id FROM zones z WHERE z.name = ?4)))
//		)
func (q *Queries) UpdateHostModel(ctx context.Context, arg UpdateHostModelParams) error {
	_, err := q.db.ExecContext(ctx, updateHostModel,
		arg.Model,
		arg.Make,
		arg.Host,
		arg.Zone,
		arg.Cluster,
	)
	return err
}

const updateHostName = `-- name: UpdateHostName :exec

UPDATE
	hosts
SET
	name = ?1
WHERE
	hosts.name = ?2
	AND (
		(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
		OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
	)
`

type UpdateHostNameParams struct {
	Name    string
	Host    string
	Zone    string
	Cluster string
}

// UPDATE
//
//	UPDATE
//		hosts
//	SET
//		name = ?1
//	WHERE
//		hosts.name = ?2
//		AND (
//			(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
//			OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
//		)
func (q *Queries) UpdateHostName(ctx context.Context, arg UpdateHostNameParams) error {
	_, err := q.db.ExecContext(ctx, updateHostName,
		arg.Name,
		arg.Host,
		arg.Zone,
		arg.Cluster,
	)
	return err
}

const updateHostRack = `-- name: UpdateHostRack :exec
UPDATE
	hosts
SET
	rack = (SELECT id FROM racks r WHERE r.name = ?1)
WHERE
	hosts.name = ?2
	AND (
		(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
		OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
	)
`

type UpdateHostRackParams struct {
	Rack    string
	Host    string
	Zone    string
	Cluster string
}

// UpdateHostRack
//
//	UPDATE
//		hosts
//	SET
//		rack = (SELECT id FROM racks r WHERE r.name = ?1)
//	WHERE
//		hosts.name = ?2
//		AND (
//			(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
//			OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
//		)
func (q *Queries) UpdateHostRack(ctx context.Context, arg UpdateHostRackParams) error {
	_, err := q.db.ExecContext(ctx, updateHostRack,
		arg.Rack,
		arg.Host,
		arg.Zone,
		arg.Cluster,
	)
	return err
}

const updateHostRank = `-- name: UpdateHostRank :exec
UPDATE
	hosts
SET
	rank = ?1
WHERE
	hosts.name = ?2
	AND (
		(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
		OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
	)
`

type UpdateHostRankParams struct {
	Rank    *int64
	Host    string
	Zone    string
	Cluster string
}

// UpdateHostRank
//
//	UPDATE
//		hosts
//	SET
//		rank = ?1
//	WHERE
//		hosts.name = ?2
//		AND (
//			(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
//			OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
//		)
func (q *Queries) UpdateHostRank(ctx context.Context, arg UpdateHostRankParams) error {
	_, err := q.db.ExecContext(ctx, updateHostRank,
		arg.Rank,
		arg.Host,
		arg.Zone,
		arg.Cluster,
	)
	return err
}

const updateHostSlot = `-- name: UpdateHostSlot :exec
UPDATE
	hosts
SET
	slot = ?1
WHERE
	hosts.name = ?2
	AND (
		(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
		OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
	)
`

type UpdateHostSlotParams struct {
	Slot    *int64
	Host    string
	Zone    string
	Cluster string
}

// UpdateHostSlot
//
//	UPDATE
//		hosts
//	SET
//		slot = ?1
//	WHERE
//		hosts.name = ?2
//		AND (
//			(zone = (SELECT id FROM zones z WHERE z.name = ?3) AND cluster IS NULL)
//			OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?4 AND zone = (SELECT id FROM zones z WHERE z.name = ?3)))
//		)
func (q *Queries) UpdateHostSlot(ctx context.Context, arg UpdateHostSlotParams) error {
	_, err := q.db.ExecContext(ctx, updateHostSlot,
		arg.Slot,
		arg.Host,
		arg.Zone,
		arg.Cluster,
	)
	return err
}
