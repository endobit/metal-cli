// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: host_attr.sql

package db

import (
	"context"
)

const createHostAttribute = `-- name: CreateHostAttribute :exec

INSERT INTO attributes (
	entity,
	object,
	name
)
VALUES (
	(SELECT id FROM entities WHERE name = 'host'),
	(SELECT id FROM hosts h WHERE h.name = ?1 AND (
		(zone = (SELECT id FROM zones z WHERE z.name = ?2) AND cluster IS NULL)
		OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?3 AND zone = (SELECT id FROM zones z WHERE z.name = ?2)))
	)),
	?4
)
`

type CreateHostAttributeParams struct {
	Host    string
	Zone    string
	Cluster string
	Name    string
}

// CREATE
//
//	INSERT INTO attributes (
//		entity,
//		object,
//		name
//	)
//	VALUES (
//		(SELECT id FROM entities WHERE name = 'host'),
//		(SELECT id FROM hosts h WHERE h.name = ?1 AND (
//			(zone = (SELECT id FROM zones z WHERE z.name = ?2) AND cluster IS NULL)
//			OR (cluster = (SELECT id FROM clusters c WHERE c.name = ?3 AND zone = (SELECT id FROM zones z WHERE z.name = ?2)))
//		)),
//		?4
//	)
func (q *Queries) CreateHostAttribute(ctx context.Context, arg CreateHostAttributeParams) error {
	_, err := q.db.ExecContext(ctx, createHostAttribute,
		arg.Host,
		arg.Zone,
		arg.Cluster,
		arg.Name,
	)
	return err
}

const readHostAttribute = `-- name: ReadHostAttribute :one
SELECT
	a.id,
	a.name,
	a.value,
	a.is_protected,
	h.name AS host,
	z.name AS zone,
	c.name AS cluster
FROM
	attributes a
JOIN
	entities e ON a.entity = e.id
JOIN
	hosts h ON a.object = h.id
LEFT JOIN
	zones z ON COALESCE(h.zone, c.zone) = z.id
LEFT JOIN
	clusters c ON h.cluster = c.id
WHERE
	e.name = 'host'
	AND h.name = ?1
	AND (
		(h.zone IS NOT NULL AND z.name = ?2)
		OR (h.cluster IS NOT NULL AND c.name = ?3 AND z.name = ?2)
	)
	AND a.name = ?4
`

type ReadHostAttributeParams struct {
	Host    string
	Zone    string
	Cluster string
	Attr    string
}

type ReadHostAttributeRow struct {
	ID          int64
	Name        string
	Value       *string
	IsProtected int64
	Host        string
	Zone        *string
	Cluster     *string
}

// ReadHostAttribute
//
//	SELECT
//		a.id,
//		a.name,
//		a.value,
//		a.is_protected,
//		h.name AS host,
//		z.name AS zone,
//		c.name AS cluster
//	FROM
//		attributes a
//	JOIN
//		entities e ON a.entity = e.id
//	JOIN
//		hosts h ON a.object = h.id
//	LEFT JOIN
//		zones z ON COALESCE(h.zone, c.zone) = z.id
//	LEFT JOIN
//		clusters c ON h.cluster = c.id
//	WHERE
//		e.name = 'host'
//		AND h.name = ?1
//		AND (
//			(h.zone IS NOT NULL AND z.name = ?2)
//			OR (h.cluster IS NOT NULL AND c.name = ?3 AND z.name = ?2)
//		)
//		AND a.name = ?4
func (q *Queries) ReadHostAttribute(ctx context.Context, arg ReadHostAttributeParams) (ReadHostAttributeRow, error) {
	row := q.db.QueryRowContext(ctx, readHostAttribute,
		arg.Host,
		arg.Zone,
		arg.Cluster,
		arg.Attr,
	)
	var i ReadHostAttributeRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Value,
		&i.IsProtected,
		&i.Host,
		&i.Zone,
		&i.Cluster,
	)
	return i, err
}

const readHostAttributes = `-- name: ReadHostAttributes :many

SELECT
	a.id,
	a.name,
	a.value,
	a.is_protected,
	h.name AS host,
	z.name AS zone,
	c.name AS cluster
FROM
	attributes a
JOIN
	entities e ON a.entity = e.id
JOIN
	hosts h ON a.object = h.id
LEFT JOIN
	zones z ON COALESCE(h.zone, c.zone) = z.id
LEFT JOIN
	clusters c ON h.cluster = c.id
WHERE
	e.name = 'host'
ORDER BY
	z.name,
	COALESCE(c.name, ''),
	h.name,
	a.name
LIMIT
	COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
`

type ReadHostAttributesParams struct {
	Offset interface{}
	Limit  interface{}
}

type ReadHostAttributesRow struct {
	ID          int64
	Name        string
	Value       *string
	IsProtected int64
	Host        string
	Zone        *string
	Cluster     *string
}

// READ
//
//	SELECT
//		a.id,
//		a.name,
//		a.value,
//		a.is_protected,
//		h.name AS host,
//		z.name AS zone,
//		c.name AS cluster
//	FROM
//		attributes a
//	JOIN
//		entities e ON a.entity = e.id
//	JOIN
//		hosts h ON a.object = h.id
//	LEFT JOIN
//		zones z ON COALESCE(h.zone, c.zone) = z.id
//	LEFT JOIN
//		clusters c ON h.cluster = c.id
//	WHERE
//		e.name = 'host'
//	ORDER BY
//		z.name,
//		COALESCE(c.name, ''),
//		h.name,
//		a.name
//	LIMIT
//		COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
func (q *Queries) ReadHostAttributes(ctx context.Context, arg ReadHostAttributesParams) ([]ReadHostAttributesRow, error) {
	rows, err := q.db.QueryContext(ctx, readHostAttributes, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadHostAttributesRow
	for rows.Next() {
		var i ReadHostAttributesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Value,
			&i.IsProtected,
			&i.Host,
			&i.Zone,
			&i.Cluster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readHostAttributesByCluster = `-- name: ReadHostAttributesByCluster :many
SELECT
	a.id,
	a.name,
	a.value,
	a.is_protected,
	h.name AS host,
	z.name AS zone,
	c.name AS cluster
FROM
	attributes a
JOIN
	entities e ON a.entity = e.id
JOIN
	hosts h ON a.object = h.id
LEFT JOIN
	zones z ON COALESCE(h.zone, c.zone) = z.id
LEFT JOIN
	clusters c ON h.cluster = c.id
WHERE
	e.name = 'host'
	AND c.name = ?1
	AND z.name = ?2

ORDER BY
	z.name,
	c.name,
	h.name,
	a.name
LIMIT
	COALESCE(NULLIF(?4, 0), 100) OFFSET COALESCE(?3, 0)
`

type ReadHostAttributesByClusterParams struct {
	Cluster string
	Zone    string
	Offset  interface{}
	Limit   interface{}
}

type ReadHostAttributesByClusterRow struct {
	ID          int64
	Name        string
	Value       *string
	IsProtected int64
	Host        string
	Zone        *string
	Cluster     *string
}

// ReadHostAttributesByCluster
//
//	SELECT
//		a.id,
//		a.name,
//		a.value,
//		a.is_protected,
//		h.name AS host,
//		z.name AS zone,
//		c.name AS cluster
//	FROM
//		attributes a
//	JOIN
//		entities e ON a.entity = e.id
//	JOIN
//		hosts h ON a.object = h.id
//	LEFT JOIN
//		zones z ON COALESCE(h.zone, c.zone) = z.id
//	LEFT JOIN
//		clusters c ON h.cluster = c.id
//	WHERE
//		e.name = 'host'
//		AND c.name = ?1
//		AND z.name = ?2
//
//	ORDER BY
//		z.name,
//		c.name,
//		h.name,
//		a.name
//	LIMIT
//		COALESCE(NULLIF(?4, 0), 100) OFFSET COALESCE(?3, 0)
func (q *Queries) ReadHostAttributesByCluster(ctx context.Context, arg ReadHostAttributesByClusterParams) ([]ReadHostAttributesByClusterRow, error) {
	rows, err := q.db.QueryContext(ctx, readHostAttributesByCluster,
		arg.Cluster,
		arg.Zone,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadHostAttributesByClusterRow
	for rows.Next() {
		var i ReadHostAttributesByClusterRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Value,
			&i.IsProtected,
			&i.Host,
			&i.Zone,
			&i.Cluster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readHostAttributesByGlob = `-- name: ReadHostAttributesByGlob :many
SELECT
	a.id,
	a.name,
	a.value,
	a.is_protected,
	h.name AS host,
	z.name AS zone,
	c.name AS cluster
FROM
	attributes a
JOIN
	entities e ON a.entity = e.id
JOIN
	hosts h ON a.object = h.id
LEFT JOIN
	zones z ON COALESCE(h.zone, c.zone) = z.id
LEFT JOIN
	clusters c ON h.cluster = c.id
WHERE
	e.name = 'host'
	AND h.name = ?1
	AND (
		(h.zone IS NOT NULL AND z.name = ?2)
		OR (h.cluster IS NOT NULL AND c.name = ?3 AND z.name = ?2)
	)
	AND a.name GLOB ?4
ORDER BY
	z.name,
	COALESCE(c.name, ''),
	h.name,
	a.name
LIMIT
	COALESCE(NULLIF(?6, 0), 100) OFFSET COALESCE(?5, 0)
`

type ReadHostAttributesByGlobParams struct {
	Host    string
	Zone    string
	Cluster string
	Glob    string
	Offset  interface{}
	Limit   interface{}
}

type ReadHostAttributesByGlobRow struct {
	ID          int64
	Name        string
	Value       *string
	IsProtected int64
	Host        string
	Zone        *string
	Cluster     *string
}

// ReadHostAttributesByGlob
//
//	SELECT
//		a.id,
//		a.name,
//		a.value,
//		a.is_protected,
//		h.name AS host,
//		z.name AS zone,
//		c.name AS cluster
//	FROM
//		attributes a
//	JOIN
//		entities e ON a.entity = e.id
//	JOIN
//		hosts h ON a.object = h.id
//	LEFT JOIN
//		zones z ON COALESCE(h.zone, c.zone) = z.id
//	LEFT JOIN
//		clusters c ON h.cluster = c.id
//	WHERE
//		e.name = 'host'
//		AND h.name = ?1
//		AND (
//			(h.zone IS NOT NULL AND z.name = ?2)
//			OR (h.cluster IS NOT NULL AND c.name = ?3 AND z.name = ?2)
//		)
//		AND a.name GLOB ?4
//	ORDER BY
//		z.name,
//		COALESCE(c.name, ''),
//		h.name,
//		a.name
//	LIMIT
//		COALESCE(NULLIF(?6, 0), 100) OFFSET COALESCE(?5, 0)
func (q *Queries) ReadHostAttributesByGlob(ctx context.Context, arg ReadHostAttributesByGlobParams) ([]ReadHostAttributesByGlobRow, error) {
	rows, err := q.db.QueryContext(ctx, readHostAttributesByGlob,
		arg.Host,
		arg.Zone,
		arg.Cluster,
		arg.Glob,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadHostAttributesByGlobRow
	for rows.Next() {
		var i ReadHostAttributesByGlobRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Value,
			&i.IsProtected,
			&i.Host,
			&i.Zone,
			&i.Cluster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readHostAttributesByHost = `-- name: ReadHostAttributesByHost :many
SELECT
	a.id,
	a.name,
	a.value,
	a.is_protected,
	h.name AS host,
	z.name AS zone,
	c.name AS cluster
FROM
	attributes a
JOIN
	entities e ON a.entity = e.id
JOIN
	hosts h ON a.object = h.id
LEFT JOIN
	zones z ON COALESCE(h.zone, c.zone) = z.id
LEFT JOIN
	clusters c ON h.cluster = c.id
WHERE
	e.name = 'host'
	AND h.name = ?1
	AND (
		(h.zone IS NOT NULL AND z.name = ?2)
		OR (h.cluster IS NOT NULL AND c.name = ?3 AND z.name = ?2)
	)
ORDER BY
	z.name,
	COALESCE(c.name, ''),
	h.name,
	a.name
LIMIT
	COALESCE(NULLIF(?5, 0), 100) OFFSET COALESCE(?4, 0)
`

type ReadHostAttributesByHostParams struct {
	Host    string
	Zone    string
	Cluster string
	Offset  interface{}
	Limit   interface{}
}

type ReadHostAttributesByHostRow struct {
	ID          int64
	Name        string
	Value       *string
	IsProtected int64
	Host        string
	Zone        *string
	Cluster     *string
}

// ReadHostAttributesByHost
//
//	SELECT
//		a.id,
//		a.name,
//		a.value,
//		a.is_protected,
//		h.name AS host,
//		z.name AS zone,
//		c.name AS cluster
//	FROM
//		attributes a
//	JOIN
//		entities e ON a.entity = e.id
//	JOIN
//		hosts h ON a.object = h.id
//	LEFT JOIN
//		zones z ON COALESCE(h.zone, c.zone) = z.id
//	LEFT JOIN
//		clusters c ON h.cluster = c.id
//	WHERE
//		e.name = 'host'
//		AND h.name = ?1
//		AND (
//			(h.zone IS NOT NULL AND z.name = ?2)
//			OR (h.cluster IS NOT NULL AND c.name = ?3 AND z.name = ?2)
//		)
//	ORDER BY
//		z.name,
//		COALESCE(c.name, ''),
//		h.name,
//		a.name
//	LIMIT
//		COALESCE(NULLIF(?5, 0), 100) OFFSET COALESCE(?4, 0)
func (q *Queries) ReadHostAttributesByHost(ctx context.Context, arg ReadHostAttributesByHostParams) ([]ReadHostAttributesByHostRow, error) {
	rows, err := q.db.QueryContext(ctx, readHostAttributesByHost,
		arg.Host,
		arg.Zone,
		arg.Cluster,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadHostAttributesByHostRow
	for rows.Next() {
		var i ReadHostAttributesByHostRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Value,
			&i.IsProtected,
			&i.Host,
			&i.Zone,
			&i.Cluster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readHostAttributesByZone = `-- name: ReadHostAttributesByZone :many
SELECT
	a.id,
	a.name,
	a.value,
	a.is_protected,
	h.name AS host,
	z.name AS zone,
	c.name AS cluster
FROM
	attributes a
JOIN
	entities e ON a.entity = e.id
JOIN
	hosts h ON a.object = h.id
LEFT JOIN
	zones z ON COALESCE(h.zone, c.zone) = z.id
LEFT JOIN
	clusters c ON h.cluster = c.id
WHERE
	e.name = 'host'
	AND z.name = ?1
ORDER BY
	z.name,
	COALESCE(c.name, ''),
	h.name,
	a.name
LIMIT
	COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
`

type ReadHostAttributesByZoneParams struct {
	Zone   string
	Offset interface{}
	Limit  interface{}
}

type ReadHostAttributesByZoneRow struct {
	ID          int64
	Name        string
	Value       *string
	IsProtected int64
	Host        string
	Zone        *string
	Cluster     *string
}

// ReadHostAttributesByZone
//
//	SELECT
//		a.id,
//		a.name,
//		a.value,
//		a.is_protected,
//		h.name AS host,
//		z.name AS zone,
//		c.name AS cluster
//	FROM
//		attributes a
//	JOIN
//		entities e ON a.entity = e.id
//	JOIN
//		hosts h ON a.object = h.id
//	LEFT JOIN
//		zones z ON COALESCE(h.zone, c.zone) = z.id
//	LEFT JOIN
//		clusters c ON h.cluster = c.id
//	WHERE
//		e.name = 'host'
//		AND z.name = ?1
//	ORDER BY
//		z.name,
//		COALESCE(c.name, ''),
//		h.name,
//		a.name
//	LIMIT
//		COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
func (q *Queries) ReadHostAttributesByZone(ctx context.Context, arg ReadHostAttributesByZoneParams) ([]ReadHostAttributesByZoneRow, error) {
	rows, err := q.db.QueryContext(ctx, readHostAttributesByZone, arg.Zone, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadHostAttributesByZoneRow
	for rows.Next() {
		var i ReadHostAttributesByZoneRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Value,
			&i.IsProtected,
			&i.Host,
			&i.Zone,
			&i.Cluster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHostAttributeName = `-- name: UpdateHostAttributeName :exec

UPDATE
	attributes
SET
	name = ?1
WHERE
	attributes.name = ?2
	AND entity = (SELECT id FROM entities WHERE name = 'host')
	AND object = (
		SELECT
			id
		FROM
			hosts h
		WHERE
			h.name = ?3
		AND (
			(h.zone = (SELECT id FROM zones z WHERE z.name = ?4) AND h.cluster IS NULL)
			OR (h.cluster = (SELECT id FROM clusters c WHERE c.name = ?5 AND zone = (SELECT id FROM zones z WHERE z.name = ?4)))
		)
	)
`

type UpdateHostAttributeNameParams struct {
	Name    string
	Attr    string
	Host    string
	Zone    string
	Cluster string
}

// UPDATE
//
//	UPDATE
//		attributes
//	SET
//		name = ?1
//	WHERE
//		attributes.name = ?2
//		AND entity = (SELECT id FROM entities WHERE name = 'host')
//		AND object = (
//			SELECT
//				id
//			FROM
//				hosts h
//			WHERE
//				h.name = ?3
//			AND (
//				(h.zone = (SELECT id FROM zones z WHERE z.name = ?4) AND h.cluster IS NULL)
//				OR (h.cluster = (SELECT id FROM clusters c WHERE c.name = ?5 AND zone = (SELECT id FROM zones z WHERE z.name = ?4)))
//			)
//		)
func (q *Queries) UpdateHostAttributeName(ctx context.Context, arg UpdateHostAttributeNameParams) error {
	_, err := q.db.ExecContext(ctx, updateHostAttributeName,
		arg.Name,
		arg.Attr,
		arg.Host,
		arg.Zone,
		arg.Cluster,
	)
	return err
}

const updateHostAttributeProtection = `-- name: UpdateHostAttributeProtection :exec
UPDATE
	attributes
SET
	is_protected = ?1
WHERE
	attributes.name = ?2
	AND entity = (SELECT id FROM entities WHERE name = 'host')
	AND object = (
		SELECT
			id
		FROM
			hosts h
		WHERE
			h.name = ?3
		AND (
			(h.zone = (SELECT id FROM zones z WHERE z.name = ?4) AND h.cluster IS NULL)
			OR (h.cluster = (SELECT id FROM clusters c WHERE c.name = ?5 AND zone = (SELECT id FROM zones z WHERE z.name = ?4)))
		)
	)
`

type UpdateHostAttributeProtectionParams struct {
	IsProtected int64
	Attr        string
	Host        string
	Zone        string
	Cluster     string
}

// UpdateHostAttributeProtection
//
//	UPDATE
//		attributes
//	SET
//		is_protected = ?1
//	WHERE
//		attributes.name = ?2
//		AND entity = (SELECT id FROM entities WHERE name = 'host')
//		AND object = (
//			SELECT
//				id
//			FROM
//				hosts h
//			WHERE
//				h.name = ?3
//			AND (
//				(h.zone = (SELECT id FROM zones z WHERE z.name = ?4) AND h.cluster IS NULL)
//				OR (h.cluster = (SELECT id FROM clusters c WHERE c.name = ?5 AND zone = (SELECT id FROM zones z WHERE z.name = ?4)))
//			)
//		)
func (q *Queries) UpdateHostAttributeProtection(ctx context.Context, arg UpdateHostAttributeProtectionParams) error {
	_, err := q.db.ExecContext(ctx, updateHostAttributeProtection,
		arg.IsProtected,
		arg.Attr,
		arg.Host,
		arg.Zone,
		arg.Cluster,
	)
	return err
}

const updateHostAttributeValue = `-- name: UpdateHostAttributeValue :exec
UPDATE
	attributes
SET
	value = ?1
WHERE
	attributes.name = ?2
	AND entity = (SELECT id FROM entities WHERE name = 'host')
	AND object = (
		SELECT
			id
		FROM
			hosts h
		WHERE
			h.name = ?3
		AND (
			(h.zone = (SELECT id FROM zones z WHERE z.name = ?4) AND h.cluster IS NULL)
			OR (h.cluster = (SELECT id FROM clusters c WHERE c.name = ?5 AND zone = (SELECT id FROM zones z WHERE z.name = ?4)))
		)
	)
`

type UpdateHostAttributeValueParams struct {
	Value   *string
	Attr    string
	Host    string
	Zone    string
	Cluster string
}

// UpdateHostAttributeValue
//
//	UPDATE
//		attributes
//	SET
//		value = ?1
//	WHERE
//		attributes.name = ?2
//		AND entity = (SELECT id FROM entities WHERE name = 'host')
//		AND object = (
//			SELECT
//				id
//			FROM
//				hosts h
//			WHERE
//				h.name = ?3
//			AND (
//				(h.zone = (SELECT id FROM zones z WHERE z.name = ?4) AND h.cluster IS NULL)
//				OR (h.cluster = (SELECT id FROM clusters c WHERE c.name = ?5 AND zone = (SELECT id FROM zones z WHERE z.name = ?4)))
//			)
//		)
func (q *Queries) UpdateHostAttributeValue(ctx context.Context, arg UpdateHostAttributeValueParams) error {
	_, err := q.db.ExecContext(ctx, updateHostAttributeValue,
		arg.Value,
		arg.Attr,
		arg.Host,
		arg.Zone,
		arg.Cluster,
	)
	return err
}
