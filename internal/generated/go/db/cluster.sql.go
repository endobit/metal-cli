// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cluster.sql

package db

import (
	"context"
)

const createCluster = `-- name: CreateCluster :exec

INSERT INTO clusters (
	name,
	zone
)
VALUES (
	?1,
	(SELECT id FROM zones z WHERE z.name = ?2)
)
`

type CreateClusterParams struct {
	Name string
	Zone string
}

// CREATE
//
//	INSERT INTO clusters (
//		name,
//		zone
//	)
//	VALUES (
//		?1,
//		(SELECT id FROM zones z WHERE z.name = ?2)
//	)
func (q *Queries) CreateCluster(ctx context.Context, arg CreateClusterParams) error {
	_, err := q.db.ExecContext(ctx, createCluster, arg.Name, arg.Zone)
	return err
}

const deleteCluster = `-- name: DeleteCluster :exec

DELETE FROM
	clusters
WHERE
	clusters.id = ?1
`

type DeleteClusterParams struct {
	ID int64
}

// DELETE
//
//	DELETE FROM
//		clusters
//	WHERE
//		clusters.id = ?1
func (q *Queries) DeleteCluster(ctx context.Context, arg DeleteClusterParams) error {
	_, err := q.db.ExecContext(ctx, deleteCluster, arg.ID)
	return err
}

const readCluster = `-- name: ReadCluster :one
SELECT
	c.id,
	c.name,
	z.name AS zone
FROM
	clusters c
JOIN
	zones z ON c.zone = z.id
WHERE
	c.name = ?1
	AND z.name = ?2
`

type ReadClusterParams struct {
	Name string
	Zone string
}

type ReadClusterRow struct {
	ID   int64
	Name string
	Zone string
}

// ReadCluster
//
//	SELECT
//		c.id,
//		c.name,
//		z.name AS zone
//	FROM
//		clusters c
//	JOIN
//		zones z ON c.zone = z.id
//	WHERE
//		c.name = ?1
//		AND z.name = ?2
func (q *Queries) ReadCluster(ctx context.Context, arg ReadClusterParams) (ReadClusterRow, error) {
	row := q.db.QueryRowContext(ctx, readCluster, arg.Name, arg.Zone)
	var i ReadClusterRow
	err := row.Scan(&i.ID, &i.Name, &i.Zone)
	return i, err
}

const readClusters = `-- name: ReadClusters :many

SELECT
	c.id,
	c.name,
	z.name AS zone
FROM
	clusters c
JOIN
	zones z ON c.zone = z.id
ORDER BY
	z.name,
	c.name
LIMIT
	COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
`

type ReadClustersParams struct {
	Offset interface{}
	Limit  interface{}
}

type ReadClustersRow struct {
	ID   int64
	Name string
	Zone string
}

// READ
//
//	SELECT
//		c.id,
//		c.name,
//		z.name AS zone
//	FROM
//		clusters c
//	JOIN
//		zones z ON c.zone = z.id
//	ORDER BY
//		z.name,
//		c.name
//	LIMIT
//		COALESCE(NULLIF(?2, 0), 100) OFFSET COALESCE(?1, 0)
func (q *Queries) ReadClusters(ctx context.Context, arg ReadClustersParams) ([]ReadClustersRow, error) {
	rows, err := q.db.QueryContext(ctx, readClusters, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadClustersRow
	for rows.Next() {
		var i ReadClustersRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Zone); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readClustersByGlob = `-- name: ReadClustersByGlob :many
SELECT
	c.id,
	c.name,
	z.name AS zone
FROM
	clusters c
JOIN
	zones z ON c.zone = z.id
WHERE
	z.name = ?1
	AND c.name GLOB ?2
ORDER BY
	c.name
LIMIT
	COALESCE(NULLIF(?4, 0), 100) OFFSET COALESCE(?3, 0)
`

type ReadClustersByGlobParams struct {
	Zone   string
	Glob   string
	Offset interface{}
	Limit  interface{}
}

type ReadClustersByGlobRow struct {
	ID   int64
	Name string
	Zone string
}

// ReadClustersByGlob
//
//	SELECT
//		c.id,
//		c.name,
//		z.name AS zone
//	FROM
//		clusters c
//	JOIN
//		zones z ON c.zone = z.id
//	WHERE
//		z.name = ?1
//		AND c.name GLOB ?2
//	ORDER BY
//		c.name
//	LIMIT
//		COALESCE(NULLIF(?4, 0), 100) OFFSET COALESCE(?3, 0)
func (q *Queries) ReadClustersByGlob(ctx context.Context, arg ReadClustersByGlobParams) ([]ReadClustersByGlobRow, error) {
	rows, err := q.db.QueryContext(ctx, readClustersByGlob,
		arg.Zone,
		arg.Glob,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadClustersByGlobRow
	for rows.Next() {
		var i ReadClustersByGlobRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Zone); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readClustersByZone = `-- name: ReadClustersByZone :many
SELECT
	c.id,
	c.name,
	z.name AS zone
FROM
	clusters c
JOIN
	zones z ON c.zone = z.id
WHERE
	z.name = ?1
ORDER BY
	c.name
LIMIT
	COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
`

type ReadClustersByZoneParams struct {
	Zone   string
	Offset interface{}
	Limit  interface{}
}

type ReadClustersByZoneRow struct {
	ID   int64
	Name string
	Zone string
}

// ReadClustersByZone
//
//	SELECT
//		c.id,
//		c.name,
//		z.name AS zone
//	FROM
//		clusters c
//	JOIN
//		zones z ON c.zone = z.id
//	WHERE
//		z.name = ?1
//	ORDER BY
//		c.name
//	LIMIT
//		COALESCE(NULLIF(?3, 0), 100) OFFSET COALESCE(?2, 0)
func (q *Queries) ReadClustersByZone(ctx context.Context, arg ReadClustersByZoneParams) ([]ReadClustersByZoneRow, error) {
	rows, err := q.db.QueryContext(ctx, readClustersByZone, arg.Zone, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadClustersByZoneRow
	for rows.Next() {
		var i ReadClustersByZoneRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Zone); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClusterName = `-- name: UpdateClusterName :exec

UPDATE
	clusters
SET
	name = ?1
WHERE
	clusters.name = ?2
	AND zone = (SELECT id FROM zones z WHERE z.name = ?3)
`

type UpdateClusterNameParams struct {
	Name    string
	Cluster string
	Zone    string
}

// UPDATE
//
//	UPDATE
//		clusters
//	SET
//		name = ?1
//	WHERE
//		clusters.name = ?2
//		AND zone = (SELECT id FROM zones z WHERE z.name = ?3)
func (q *Queries) UpdateClusterName(ctx context.Context, arg UpdateClusterNameParams) error {
	_, err := q.db.ExecContext(ctx, updateClusterName, arg.Name, arg.Cluster, arg.Zone)
	return err
}
